Our file storage design builds off of Design 1 of the staff solution. Each user has their own directory located at '<username>/dictionary' that is encrypted with a symmetric key on the server. This directory is used to map the names of the files that are stored with a random ID number that is assigned to the file name along with other information like the key used to encrypt the value and the key used to MAC the value. When the user downloads a file, he/she checks their directory for the name of the name, retrieves the random ID, and uses that random ID and the key to retrieve and decrypt the file from the server. 

For sharing, if the user who shares the file is the original owner, then he/she puts onto the server a key-value pair containing a message '[SHARE]/<username>/sharewith/<user>/<name>' as the key and a list of information containing an IV, an encrypted list which contains the random ID, key that encrypts the value, and key for the MAC of the file value, and a MAC for the encrypted list. This is stored as '[DATA] [data iv, [random id, key for encrypting value, key for MAC of value], MAC of the list'. The list inside is encrypted via symmetric key encryption using AES-CBC and this key is sent through the message. The MAC uses SHA256 and its key is also sent in the message. The message is encrypted asymmetrically using the recipients public key. Then the user sends a message to the receiver which consists of the key that was just uploaded. Basically, the user doesn't send the actual file, he/she just gives a pointer that leads to information used to unlock the file. When the receiver calls receive_share, he/she puts onto the server a key-value pair containing '<username>/<newname>' and a pointer to the key-value pair that was uploaded in share. This way, when the receiver tries to download the file, the pointers take the user to the data that contains information about the file's random ID and the necessary keys.If the user who shares the file is not the original user, a [SHARE] tag is used to designate that the user was shared the file. This way, when a user who was shared a file shares it with someone else, they can just have a pointer which goes through them and eventually to the information to unlock the file. So instead of putting a list of values onto the server, the user just puts a pointer (like '[POINTER] <username>/<name>'). Users also update their directories in receive_share to store the information necessary to access the data containing information to the file. Also, during sharing the user keeps track of a list of users that he/she directly shared the file with. This will be important for revoking.


Our system does efficient updates by storing the differences between files onto the server. On the first time a user uploads, he/she stores the value in a cache. Then we the user makes an update, the edits are calculated and stored.


For revoking, the server deletes the pointer on the server so the revoked user can't follow it back to the infomation of the file. But since the user will have the information in their directory, we have to change the random ID of the file, and change the keys used to encrypt and MAC it. Then we go through the list of users that the file was directy shared with and change the pointers to point to the new informaton. If the user is revoked, then we don't change their pointer so they can't have access to the new information. Revoked users can't make changes to the file or see updates because the random ID will have been changed. We only need to change it for direct children because grandchildren will just follow the pointers to get to the file information. This also means that children of the revoked user also don't have access to the file. 



Security attacks/defenses:

We prevent main in the middle attacks by using MACs. When the user wants to decrypt data, he/she checks the MAC to see if there are any changes to the data. If the MACs are not equal something has changed so we can raise an error.

We prevent eavesdroppers by encrypting our data. 

We prevent revoked users from updating or seeing updates by changing the random ID and key of the file. This way, even if they have old information they can't make or see new changes.  
 