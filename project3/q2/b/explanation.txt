a) Procedure: Because of the fault in the code thatâ€™s explained in part b, we knew that the original seed would have to just be a number roughly between 0 and 8000. So we changed the seed function to accept an integer (well, a string that we turn into an integer since the bash script will input a string), and left the rest of generate_rsa_pairs.c the same. Then, in the bash script, we iterated through the numbers 0 and 8000 and fed it one by one to generate_rsa_pairs.c until the seed produced a public key that matched the public key that was given (server_publickey.pub). Then, we use the private key produced by this in order to decode the chat log when using Wireshark to connect to eth1. We follow the same procedures as part 2a to set up Wireshark. Then we look at the GET /chat.html and the next packet HTTP/1.0 200 ok and examine the decrypted SSL data to see the chat in plaintext. I got the secret from the conversation.

b) Line 148 doesn't do what the comment above it says it will do. The comment says that the number of microseconds since time_in_sec will be added, but the "seed" value is just replaced with time_micro_sec >> 7. There is about 2^20 microseconds in a second, and right shifting that by 7 means that there's about 2^13 ~= 8192 values at the most (actually about 10^6/2^7 ~= 7812.5) possibilities for the seed. This means that there's a significantly smaller amount of entropy than was intended; if the code were to be fixed, then this key generation scheme would be secure since there would be about 32 bits of entropy (since there's about 2^31 seconds since epoc + 2^20 microseconds which is trivial). 
